clear
close all
clc

% Dati

G = 6.67e-11; % N*m^2/kg^2

m_T = 5.974e24;  % kg
m_S = 1.989e30;  % kg
m_A = 5.1827e11; % Kg

R_T = 6378;   % km
R_S = 696340; % km
R_A = 0.79/2; % km

mu_T = 398600;  % km^3/s^2
mu_S = 1.32712440042e20 * 0.001^3; % km^3/s^2
mu_A = G * m_A;


dth = 0.1;

% !!!! RIFERITA ALLA TERRA
O_parcheggio.a = 3.918174284575137e+04; % km
O_parcheggio.e = 0.597404804289614;
O_parcheggio.i = 0.590342952766537;
O_parcheggio.OM = 1.749480463333461;
O_parcheggio.om = 1.177309652253865;
O_parcheggio.mu = 398600;
[rr_start_T, vv_start_T] = par2car(O_parcheggio, 0); % Per ora mi metto nel pericentro; SdR Terra


% Sarebbe l'orbita di parcheggio del nostro gruppo, dello scenario 1

% Terra !!!! RIFERITA AL SOLE
O_start_scenario2.a = 1.4946e8;  % [km]
O_start_scenario2.e = 0.016;     % [ ]
O_start_scenario2.i = 9.1920e-5; % [rad]
O_start_scenario2.OM = 2.7847;   % [rad]
O_start_scenario2.om = 5.2643;   % [rad]
O_start_scenario2.mu = mu_S;       % [km^3/s^2]
th1_scenario2 = 3.618362149407213; % [rad]
[rr_end1_S, vv_end1_S] = par2car (O_start_scenario2, th1_scenario2); % SdR Sole

% Trasferimento dello scenario 2 !!! Riferita al sole
O_t_scenario2.a = 1.481231188816134e+08;
O_t_scenario2.e = 0.028295312693238;
O_t_scenario2.i = 0.043993770239157;
O_t_scenario2.OM = 5.382908205403476;
O_t_scenario2.om = 3.729157082348018;
O_t_scenario2.mu = 1.327124400420000e+11;
th1_transfer = 2.555106932985983;
th2_transfer = 4.871467598525006;

[rr_t1, vv_t1, matrici] = par2car(O_t_scenario2, th1_transfer); % Coordinate cartesiane 
% rispetto al sole del satellite quando fa la manovra, la velocità è la
% velocità subito dopo l'impulso, quindi sta già percorrendo l'orbita di
% trasferimento

% Per approssimazione della patched conics, uscito dalla SOI terrestre,
% posso confondere la posizione del satellite con quella del pianeta,
% quindi, centrandomi nella terra, scelgo il punto in cui passo ad
% un'iperbole e da lì vado all'infinito
% Per questa prima iperbole il piano è lo stesso dell'orbita di parcheggio,
% visto che bisogna aumentare l'energia, direi che conviene fissare il
% pericentro con il pericentro dell'orbita di parcheggio
% Voglio arrivare all'infinito con, nel SdR Sole, la velocità che mi
% permette di percorre l'orbita di trasferimento dello scenario 2, è così
% imposta la v_inf dell'iperbole rispetto alla terra

vv_inf1 = vv_t1 - vv_end1_S; % Velocità dell'orbita di T - la velocità 
% della terra ==> Velocità infinito dell'iperbole relativa alla terra
% ! Dovrebbe essere rispetto alla terra.

% Il raggio di pericentro dell'iperbole, lo facciamo coincidere col
% pericentro del'orbita di parcheggio:
rp_parcheggio = r_parametrica(O_parcheggio, 0); % rp_iperbole1
vp_parcheggio = v_theta(O_parcheggio, 0)

% Caratterizzo l'orbita iperbolica, per trovarne v nel pericentro
O_hyper1.a = -mu_T/norm(vv_inf1)^2; % Dalla conservazione dell'energia meccanica

% Passando per l'equazione della conica al pericentro
O_hyper1.e = (O_hyper1.a-rp_parcheggio)/O_hyper1.a;
O_hyper1.i = 0.590342952766537;
O_hyper1.OM = 1.749480463333461;
O_hyper1.om = 1.177309652253865; % Stesso piano e orientazione dell'orbita di parcheggio
O_hyper1.thetainf = acos(-1/O_hyper1.e); % 2.7413 rad %anomalia vera 'asintotica'
O_hyper1.mu = 398600;

% Trovo la velocità nel pericentro dell'orbita:
vp_hyper = v_theta(O_hyper1, 0)

% e quindi il deltaV richiesto, visto che il sistema di riferimento è lo
% stesso, ho preso le parametriche, toccherebbe verificare che sia giusto,
% ma devo andare
DELTA_V1 = abs(vp_hyper - vp_parcheggio)

%COSTO in tempo: prendo la legge oraria dell iperbole artendo da un th = 0
%(pericentro iperbole, arrivando a th tale da raggiungere il raggio della
%sfera di influenza
d_ear_sun=norm(rr_end1_S);
r_soi_ear=d_ear_sun*(m_T/m_S)^(2/5);
th_r_soi_ear=acos(1/O_hyper1.e*(O_hyper1.a*(1-O_hyper1.e^2)/r_soi_ear-1));
DELTA_T_SOI1= TOF_open(O_hyper1, 0, th_r_soi_ear)



% Vediamo se funziona, disegnando
Terra_3D(R_T)
hold on
plotOrbit (O_parcheggio, 0, 2*pi, dth, 'k--');
plotOrbit (O_hyper1, 0, O_hyper1.thetainf, dth, 'r');

% MANOVRA DI RIENTRO IN ASTEROIDE
%definisco un orbita intorno all asteroide tale da essere contenuta nella
%sfera di influenza dell asteroide rispetto al sole e che sia sullo stesso
%piano di quella di traferimento nello scenario 2

% Orbita asteroide intorno al sole
O_A.a = 0.827903 *1.496e8; % [km]
O_A.e = 0.209487;          % [ ]
O_A.i = 8.55 *pi/180;      % [rad]
O_A.OM = 273.63 *pi/180;   % [rad]
O_A.om = 327.03 *pi/180;
O_A.mu=1.32712440042e20 * 0.001^3;
% th_sc2_ast= 3.5105; % Dove era stato preso?
th_sc2_ast = 3.498164148433855; % th2 trovato con ga()

%
% calcolo sfera di influenza dell asteroide rispetto al sole
% prima cosa calcolo distanza asteroide sole nel punto in cui avviene la
% manovra
d_ast_sun=r_parametrica(O_A, th_sc2_ast); % Distanza asteroide - sole al 
% momento d'arrivo
R_SOI_A=d_ast_sun*(m_A/m_S)^(2/5);



% La velocità all'infinito dell'iperbole di rientro è definita, è quella
% dell'orbita di trasferimento in theta 2
[rr_th2_t, vv_th2_t] = par2car (O_t_scenario2, th2_transfer); % Velocità rispetto al Sole
% del satellite nell'orbita di trasferimento

[rr_th2_S, vv_th2_S] = par2car (O_A, th_sc2_ast); % Velocità rispetto al Sole
% dell'asteroide, nel punto di trasferimento

vv_inf2_S = vv_th2_t - vv_th2_S; % km/s, velocità di eccesso iperbolico, rispetto
% all'asteroide... su che piano sono?
v_inf2 = norm(vv_inf2_S);
rr_inf2_S = rr_th2_t - rr_th2_S; % km, distanza relativa rispetto allo 
% asteroide, per approssimazione delle patched conics, = 0
O_hyper2.i = O_t_scenario2.i;
O_hyper2.om = O_t_scenario2.om;
O_hyper2.OM = O_t_scenario2.OM;

O_hyper2.a = - mu_A/v_inf2^2;
O_hyper2.mu = mu_A;
% Ignorando per ora i piani in cui giaccio, posso trovare il costo minimo
% della manovra, costruendo l'ellisse con la velocità più alta possibile al
% pericentro

% bisogna quindi scegliere un orbita con raggio massimo di 5.4226 km 
%OSS: datemi comferma ma volendo ottimizzare la manovra forse conviene un
%orbita molto ellittica così la velocità di pericentro è alta e risparmio
%carburante, giac d'accordo
r_a = 0.9*R_SOI_A; % Margine del 10%, aumentandolo, aumentano i costi della
% manovra
r_p = 1.2*R_A;

O_hyper2.e = (O_hyper2.a-r_p)/O_hyper2.a;
O_hyper2.thetainf = acos(-1/O_hyper2.e);



% Dell'orbita d'arrivo impongo solo r_a
O_arrivo.mu = mu_A;
O_arrivo.a=(r_a+r_p)/2;
O_arrivo.e=(r_a-r_p)/2/O_arrivo.a;
O_arrivo.i = O_hyper2.i;
O_arrivo.om = O_hyper2.om;
O_arrivo.OM = O_hyper2.OM;
% Quindi, l'impulso finale per pormi nell'ultima orbita di parcheggio, sarà
DELTA_V2 = abs (v_theta (O_arrivo, 0) - v_theta (O_hyper2, 0))


%COSTO in tempo: prendo la legge oraria dell iperbole artendo da un th = 0
%(pericentro iperbole, arrivando a th tale da raggiungere il raggio della
%sfera di influenza

th_r_soi_ast=acos(1/O_hyper2.e*(O_hyper2.a*(1-O_hyper2.e^2)/R_SOI_A-1));
DELTA_T_SOI2= TOF_open(O_hyper2, 0, th_r_soi_ast)
figure
Terra_3D(0.36)
hold on
plotOrbit (O_arrivo, 0, 2*pi, dth, 'k--');
plotOrbit (O_hyper2, 0, O_hyper2.thetainf, dth, 'r');


%APPROFONDIMENTO%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Cerco il piano in cui giacciono le orbite, per farlo devo ruotare il
% sistema di riferimento cartesiano eliocentrico, lungo l'asse x, di eps,
% cioè l'inclinazione del piano equatoriale dell'asteroide rispetto al
% piano dell'eclittica:
eps_A = 8.51490 * pi/180; % [rad], fonte: wikipedia

% Quindi l'angolazione dell'orbita parabolica e d'arrivo, rispetto al SdR
% inerziale dell'asteroide, cambierà solo in i:
O_hyper2.i = O_t_scenario2.i;
O_hyper2.om = O_t_scenario2.om;
O_hyper2.OM = O_t_scenario2.OM;
O_arrivo.i = O_hyper2.i;
O_arrivo.om = O_hyper2.om;
O_arrivo.OM = O_hyper2.OM;

figure
scatter3(0,0,0, 100, 'yellow', 'filled') % SOLE
hold on
scatter3(rr_th2_S(1), rr_th2_S(2), rr_th2_S(3), 'red', 'filled') % ASTEROIDE
scatter3(rr_end1_S(1), rr_end1_S(2), rr_end1_S(3), 'blue', 'filled') % TERRA
plotOrbit (O_t_scenario2, 0, 2*pi, dth, 'k--');
plotOrbit (O_A, 0, 2*pi, dth, 'k--');
% plotOrbit (O_arrivo, 0, 2*pi, dth, 'k--');
plotOrbit (O_hyper2, 0, O_hyper2.thetainf, dth, 'green', rr_th2_S);


%% avanzato

clear all
close all
clc

% Dati

G = 6.67e-11; % N*m^2/kg^2

m_T = 5.974e24;  % kg
m_S = 1.989e30;  % kg
m_A = 5.1827e11; % Kg

R_T = 6378;   % km
R_S = 696340; % km
R_A = 0.79/2; % km

mu_T = 398600;  % km^3/s^2
mu_S = 1.32712440042e20 * 0.001^3; % km^3/s^2
mu_A = G * m_A;


dth = 0.1;

% !!!! RIFERITA ALLA TERRA
O_parcheggio.a = 3.918174284575137e+04; % km
O_parcheggio.e = 0.597404804289614;
O_parcheggio.i = 0.590342952766537;
O_parcheggio.OM = 1.749480463333461;
O_parcheggio.om = 1.177309652253865;
O_parcheggio.mu = 398600;
[rr_start_T, vv_start_T] = par2car(O_parcheggio, 0); % Per ora mi metto nel pericentro; SdR Terra


% Sarebbe l'orbita di parcheggio del nostro gruppo, dello scenario 1

% Terra !!!! RIFERITA AL SOLE
O_start_scenario2.a = 1.4946e8;  % [km]
O_start_scenario2.e = 0.016;     % [ ]
O_start_scenario2.i = 9.1920e-5; % [rad]
O_start_scenario2.OM = 2.7847;   % [rad]
O_start_scenario2.om = 5.2643;   % [rad]
O_start_scenario2.mu = mu_S;       % [km^3/s^2]
th1_scenario2 = 3.618362149407213; % [rad]
[rr_end1_S, vv_end1_S] = par2car (O_start_scenario2, th1_scenario2); % SdR Sole

% Trasferimento dello scenario 2 !!! Riferita al sole
O_t_scenario2.a = 1.481231188816134e+08;
O_t_scenario2.e = 0.028295312693238;
O_t_scenario2.i = 0.043993770239157;
O_t_scenario2.OM = 5.382908205403476;
O_t_scenario2.om = 3.729157082348018;
O_t_scenario2.mu = 1.327124400420000e+11;
th1_transfer = 2.555106932985983;
th2_transfer = 4.871467598525006;

[rr_t1, vv_t1, matrici] = par2car(O_t_scenario2, th1_transfer);
vv_inf1 = vv_t1 - vv_end1_S;
%Prova iperbole con modifica di piano
%1)modifico sistema riferimento passando da eclittico(sole) a eci(terra)
T_eci_eclip=[1 0 0;
            0 cos(eps) sin(eps);
            0 -sin(eps) cos(eps)];
vv_inf1_eci=T_eci_eclip'*vv_inf1;
rr_inf_eci=vv_inf1_eci/norm(vv_inf1_eci);

%2)scelgo r_h per esempio raggio di 90 gradi su orbita di parcheggio dell'orbita di parcheggio
[rr_h_earth,vv_h_earth]=par2car(O_parcheggio,0);
rr_h=rr_h_earth;
r_h=norm(rr_h);
alpha=acos(dot(rr_h,rr_inf_eci)./norm(rr_h)./norm(rr_inf_eci));
a_h=-O_parcheggio.mu/(norm(vv_inf1_eci).^2);
%X=[eh,theta_inf,theta_h]
fun=@(X)[(a_h*(1-X(1).^2))./(1+X(1).*cos(X(3)))-r_h;
    cos(X(2))+1./X(1);
    X(3)+alpha-X(2)
    ];
x0=[1,pi/2,0];
X=fsolve(fun,x0);
eh=X(1);
theta_inf=X(2);
theta_h=X(3);
if theta_inf>pi/2 && theta_inf>pi
    printf('modificare il raggio di intersezione')
    stop
end

%definisco il piano dell'iperbole uguale al piano dell orbita di
%trasferimento delo sc2
hh_hyper=cross(rr_t1,vv_t1)/norm(cross(rr_t1,vv_t1));
NN_h=cross([0;0;1],hh_hyper)/norm(cross([0;0;1],hh_hyper));
O_hyper_Ad.i=acos(dot(hh_hyper,[0,0,1]));
if dot(NN_h,[0,1,0])>=0
    O_hyper_Ad.OM=acos(dot(NN_h,[1,0,0]));
elseif dot(NN_h,[0,1,0])<0
     O_hyper_Ad.OM=2*pi-acos(dot(NN_h,[1,0,0]));
end
fun2=@(e)[dot(rr_h,e)-cos(theta_h);
    dot(rr_inf_eci,e)-cos(theta_inf);
    norm(e)-1
    ];
e0=[1,1,1];
ee_h=fsolve(fun2,e0);

if dot(ee_h,[0,0,1])>=0
    O_hyper_Ad.om=acos(dot(NN_h,ee_h));
elseif dot(ee_h,[0,0,1])<0
    O_hyper_Ad.om=2*pi-acos(dot(NN_h,ee_h));
end
O_hyper_Ad.a=-mu_T/norm(vv_inf1).^2;
O_hyper_Ad

%verifica grafica
% plane_parc=@(x,y)-(hh_parc(1)*x+hh_parc(2)*y)./hh_parc(3);
% plane_hyper=@(x,y)-(hh_hyper(1)*x+hh_hyper(2)*y)./hh_hyper(3);
% x=linspace(-1e16,1e16,100);
% y=linspace(-1e16,1e16,100);
% [X,Y]=meshgrid(x,y);
% figure
% % sist_can(2);
% % hold on
% % plotOrbit(O_t_scenario2,0,2*pi,0.01,'green');
% surf(plane_hyper(X,Y),LineStyle="none")
% hold on
% quiver3(0,0,0,hh_hyper(1),hh_hyper(2),hh_hyper(3))
% 
% 



%%%%%%%%%%%%%%%%%%%%%%% Parentesi Grafica %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% R_SOI_TERRA = R_t_s* (m_T/m_S)^(2/5) % km
% 
% [X, Y, Z] = sphere;
% X_SOI_TERRA = R_SOI_TERRA * X;
% Y_SOI_TERRA = R_SOI_TERRA * Y;
% Z_SOI_TERRA = R_SOI_TERRA * Z;
% 
% X_T = R_T * X;
% Y_T = R_T * Y;
% Z_T = R_T * Z;
% 
% figure
% 
% surf_T = surf (X_T, Y_T, Z_T);
% shading interp
% surf_T.FaceAlpha = 0.3;
% surf_T.EdgeColor = 'none';
% 
% hold on
% 
% surf_SOI_TERRA = surf (X_SOI_TERRA, Y_SOI_TERRA, Z_SOI_TERRA);
% shading interp
% surf_SOI_TERRA.FaceAlpha = 0.3;
% surf_SOI_TERRA.EdgeColor = 'none';
% 
% scatter3(rr_start(1), rr_start(2), rr_start(3), 'filled', LineWidth=1)
% scatter3(rr_end(1), rr_end(2), rr_end(3), 'filled', LineWidth=1)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%