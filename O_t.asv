function [orbit] = O_t(th1i,th2f,om)
%proviamo a fare una funzione che nserendo delle limitazioni in input
%restituisce l'orbita di trasferimento in output
[rri,vvi] = par2car(O_start, th1i);
[rrf,vvf] = par2car(O_end, th2f);
%identifico orbita
hh=cross(rri,rrf)./(norm(cross(rri,rrf)));
i=acos(dot(hh,[0,0,1]));
NN=cross([0,0,1],hh)./norm(cross([0,0,1],hh));
if dot(NN,[0,1,0])>=0
    OM=acos(dot(NN,[1,0,0]));
else
    OM=2*pi-acos(dot(NN,[1,0,0]));
end
R_OM=[cos(OM) sin(OM) 0;
    -sin(OM) cos(OM) 0;
    0 0 1];

% Rotazione di i intorno al versore i'
R_i=[1 0 0;
    0 cos(i) sin(i);
    0 -sin(i) cos(i)];

% Rotaziozione di om intorno al versore k''
R_om=[cos(om) sin(om) 0;
    -sin(om) cos(om) 0;
    0 0 1];
T_e_pf=R_om*R_i*R_OM;
rri_t=T_e_pf*rri;
rrf_t=T_e_pf*rrf;
th1t=atan(rri(2)/rri(2));
th2t=atan(rrf(2)/rrf(1));
%calcolo valori scalari e parametri di forma
r1=norm(rri);
r2=norm(rrf);
et=(r2-r1)/(r1*cos(th1t)-r2*cos(th2t));
at=r1*(1+et*cos(th1t))/(1-et^2);
O_t.a=at;
O_t.e=et;
O_t.i=i;
O_t.OM=OM;
O_t.om=om;
O_t.th
par2car
end





